#!/usr/bin/env python
# coding: utf-8

# # Modélisation de l'exploitation d'un puits par cycles journaliers
# 
# Calcul de la formule de Theis pour un cycle d'exploitation journalier avec *__x__ heures* de pompage et *__24 - x__ heures* de repos sur une durée d'un an environ.
# 
# Il faut renseigner :
# * le débit d'exploitation (m3/h)
# * la durée de pompage journalière (0 à 24 h en h)
# * la durée totale simulé (en mois, garder de l'ordre de 1 ou 2 ans)
# * la transmissivité (m2/s)
# * l'emmagasinnement (-)
# * les pertes de charge quadratiques (s2/m5)
# 
# 



%matplotlib qt

"""%matplotlib inline    """

# IMPORTS

import numpy as np
import matplotlib.pyplot as plt
#%matplotlib inline
from ttim import *
import pandas as pd
from scipy.special import exp1



from warnings import simplefilter
simplefilter(action="ignore", category=pd.errors.PerformanceWarning)


# FONCTIONS ##

def makePumpSerieSeconds(lenCycle, duration, rate):
    ts=[[],[]]
    u=0
    while u < (duration / 86400 +1) :
        ts[0].append(86400*u)
        ts[1].append(rate)
        ts[0].append(86400*u + lenCycle)
        ts[1].append(-rate)
        u+=1        
    return ts


# Paramètres à modifier __ci-dessous :___




# PARAM ENTREE ##

lenCycle_Hours=8.

# Etudier la sensibilité de ce paramètre
# mais 3 mois OK d'après premières analyses
duration_Months=4.

rate_M3H=4.

duration_Seconds=duration_Months*86400.*30.
lenCycle_Sec=lenCycle_Hours*3600.
rate_M3S=rate_M3H/3600.

durationModel_Years=30.
durationModel_Seconds=durationModel_Years*365.*86400.

# Paramètres à modifier __ci-dessous :___




# PARAM CALAGE ##

K = 5e-5    # m/s
b = 1.      # m
T = K * b
Ss = 0.2   # 1/m
S = Ss * b
r= 0.140/2     # m
PdCQ= 100000. # s2/m5


# Calcul mal rangé tout cracra à mettre sous forme de fonctions



# CALCUL ##

dQ=np.array(makePumpSerieSeconds(lenCycle_Sec, duration_Seconds, rate_M3S))

# print(dQ)

# transformation des donnees de delta Q en dataframe pandas
dQ_DF=pd.DataFrame(dQ.transpose())
# indexation des donnees
dQ_DF[0]=pd.to_timedelta(dQ_DF[0], 'S')
dQ_DF=dQ_DF.set_index(0)

# premier pas de temps / 1ere mesure en secondes (>= 1s)
t0=1800.

# creation des pas de temps de clacul avec n logspaces suivant le nb de debits
t_Mod=np.logspace(np.log10(t0), np.log10(dQ[0][1]), 6)

try:
    for w in dQ[0][2:]:
#        t_Mod=np.append(t_Mod, np.logspace(np.log10(t_Mod[-1]), 
#                                          np.log10(w), 
#                                          20)[1:])
        t_Mod=np.append(t_Mod, np.logspace(np.log10(t_Mod[-1]), 
                                          np.log10(w), 
                                          8)[1:])
except:
    pass

                 
# ajout de 0 en debut de serie pour le calcul des delta t
t_Mod=np.insert(t_Mod, 0, 0)

print("t_Mod : ",t_Mod)

# transformation des donnees de t en dataframe pandas
t_DF=pd.DataFrame(t_Mod)
# indexation des donnees
t_DF[0]=pd.to_timedelta(t_DF[0], 'S')
t_DF=t_DF.set_index(0)


for v in range(len(dQ[1])):
    nom1='Q'+str(v)
    s1=np.zeros(v)
    s2=np.full((len(t_DF) - v, 1), dQ[1][v])
    # print("len(s1) : ",len(s1))
    # print("len(s2) : ",len(s2))
    # print("len(s1+s2) : ",len(s1)+len(s2))
    # print("len(t_DF) : ",len(t_DF))
    t_DF[nom1]=np.append(s1,s2)
    # t_DF[nom1]=dQ[1][v]
    # print("len  t_DF[nom1] : ",len(t_DF[nom1]))
    # t_DF[nom1]["0 s":pd.Timedelta(dQ[0][v],"S")]=0 # PB
    nom2='t'+str(v)
    t_DF[nom2]=(t_DF.index-pd.Timedelta(dQ[0][v],"S")-pd.Timedelta('1s')).round('1s')

t_DF=t_DF.set_index(t_DF.index.round('1s'))


u=[[] for i in range(len(dQ[1]))]

for v in range(len(dQ[1])):
    # nom1='Q'+str(v)
    nom2='t'+str(v)
    u[v]=(r**2 *S)/(4 *T * np.array(t_DF[nom2], dtype="float")/1e9) # PB

s=[[] for i in u]

for i in range(len(u)):
    nom1='Q'+str(i)
    # s[i]=np.nan_to_num(np.array(t_DF[nom1])/(4*np.pi*T)*exp1(u[i]), nan=0)
    if i % 2 ==0 :
        s[i]=np.nan_to_num(t_DF[nom1]/(4*np.pi*T)*exp1(u[i])+t_DF[nom1]**2*PdCQ, nan=0)
    else:    
        s[i]=np.nan_to_num(t_DF[nom1]/(4*np.pi*T)*exp1(u[i])-t_DF[nom1]**2*PdCQ, nan=0)
    
s_final=np.sum(s, axis=0)


to1 = np.array(t_DF.index, dtype="float")/1e9 # temps (s)
ho1 = -s_final # rabattement (m) / '-' devant car valeurs positives de s

if to1[0] == 0 and ho1[0] == 0 :
    to1=to1[1:]
    ho1=ho1[1:]

to1=to1/86400.
# print(to1[-30:])


# ### Régression



t1=365.*1.
t2=365.*5.
tInterest_days=365.*durationModel_Years

for q,p in zip(to1, ho1):
    if abs(q - (9+(lenCycle_Hours)/24)) < 0.000001 :
        X1,Y1=q,p
    if abs(q - (duration_Months*30+(lenCycle_Hours)/24)) < 0.000001 :
#    if abs(q - (duration_Months*30)+(24-lenCycle_Hours)/24) < 0.000001 :
        X2,Y2=q,p
        
A=(Y2-Y1)/(np.log10(X2)-np.log10(X1))

Y3=Y1+A*(np.log10(t1)-np.log10(X1))
Y4=Y1+A*(np.log10(t2)-np.log10(X1))
Y5=Y1+A*(np.log10(tInterest_days)-np.log10(X1))
Y0=Y1+A*(np.log10(0.1)-np.log10(X1))

X=[0.1,X1,X2,t1,t2,tInterest_days]
Y=[Y0,Y1,Y2,Y3,Y4,Y5]


# ### Figures



# Plot figures


T_str=np.format_float_scientific(T, exp_digits=1, precision=0)

# plt.semilogx(to1, ho1, 'b-', label='Q = {} m3/h\nTemps journalier {} h\nPdc quad. = {} s2/m5'.format(rate_M3H, lenCycle_Hours, PdCQ))
plt.semilogx(to1, ho1, 'b.-', label='T = {} m2/s\nPdc quad. = {} s2/m5\nQ = {} m3/h\nTemps journalier {} h'.format(T_str, PdCQ, rate_M3H, lenCycle_Hours))

plt.semilogx([tInterest_days,tInterest_days], [0, min(ho1)*1.20], 'r-')
plt.semilogx(X,Y, 'r*-', label='s à {} ans = {:.2f} m\ns à {} ans = {:.2f} m\ns à {} ans = {:.2f} m'.format(int(t1/365), Y3, int(t2/365), Y4, int(tInterest_days/365), Y5))
plt.xlabel('Temps (j)')
plt.xlim(xmax=tInterest_days*1.2)
plt.ylim(ymin=1.25*min(ho1))
plt.ylabel('Rabattement (m)')
plt.legend()
plt.grid('True')
plt.show()








#!/usr/bin/env python
# coding: utf-8

# # Modélisation de l'exploitation d'un puits par cycles journaliers
# 
# Calcul de la formule de Theis pour un cycle d'exploitation journalier avec *__x__ heures* de pompage et *__24 - x__ heures* de repos sur une durée d'un an environ.
# 
# Il faut renseigner :
# * le débit d'exploitation (m3/h)
# * la durée de pompage journalière (0 à 24 h en h)
# * la durée totale simulé (en mois, garder de l'ordre de 1 ou 2 ans)
# * la transmissivité (m2/s)
# * l'emmagasinnement (-)
# * les pertes de charge quadratiques (s2/m5)
# 
# 



%matplotlib qt

"""%matplotlib inline    """

# IMPORTS

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from scipy.special import exp1

from warnings import simplefilter
simplefilter(action="ignore", category=pd.errors.PerformanceWarning)



# FONCTIONS ##


def makePumpSerieSeconds(pumpingData):
    duration=pumpingData['Model time S']
    rate=pumpingData['Pumping rate M3S']
    lenCycle=pumpingData['Daily pump time S']
    
    ts=[[],[]]
    u=0
    while u < (duration / 86400 +1) :
        ts[0].append(86400*u)
        ts[1].append(rate)
        ts[0].append(86400*u + lenCycle)
        ts[1].append(-rate)
        u+=1        
    return np.array(ts)


def pumpingCycleDF(pumpingArray):
    # transformation des donnees de delta Q en dataframe pandas
    dQ_DF=pd.DataFrame(pumpingArray.transpose())
    # indexation des donnees
    dQ_DF[0]=pd.to_timedelta(dQ_DF[0], 'S')
    dQ_DF=dQ_DF.set_index(0)

    # premier pas de temps / 1ere mesure en secondes (>= 1s)
    t0=1800.

    # creation des pas de temps de calcul avec n logspaces 
    # suivant le nb de debits
    t_Mod=np.logspace(np.log10(t0), np.log10(dQ[0][1]), 6)

    try:
        for w in dQ[0][2:]:
            t_Mod=np.append(t_Mod, np.logspace(np.log10(t_Mod[-1]), 
                                              np.log10(w), 
                                              8)[1:])
    except:
        pass
               
    # ajout de 0 en debut de serie pour le calcul des delta t
    t_Mod=np.insert(t_Mod, 0, 0)

    # transformation des donnees de t en dataframe pandas
    time_DF=pd.DataFrame(t_Mod)
    # indexation des donnees
    time_DF[0]=pd.to_timedelta(time_DF[0], 'S')
    time_DF=time_DF.set_index(0)

    for v in range(len(dQ[1])):
        nom1='Q'+str(v)
        s1=np.zeros(v)
        s2=np.full((len(time_DF) - v, 1), dQ[1][v])

        time_DF[nom1]=np.append(s1,s2)

        nom2='t'+str(v)
        time_DF[nom2]=(time_DF.index-pd.Timedelta(dQ[0][v],"S")  
                       - pd.Timedelta('1s')).round('1s')
                  
    time_DF=time_DF.set_index(time_DF.index.round('1s'))
    return time_DF 


def TheisQVar(parameters, pumpingArray, time_DF):
   
    # Calcul du rabattement en fonction des paramètres de pompages
    # et paramètres hydrodynamiques

    T=parameters['Transmissivity']
    S=parameters['Storage']
    r=parameters['radius']
    PdCQ=parameters['QuadHeadLoss']


    u=[[] for i in range(len(pumpingArray[1]))]

    for v in range(len(pumpingArray[1])):
        
        nom2='t'+str(v)
        u[v]=(r**2 *S)/(4 *T * np.array(time_DF[nom2], dtype="float")/1e9) # PB

    s=[[] for i in u]

    for i in range(len(u)):
        nom1='Q'+str(i)
        
        if i % 2 ==0 :
            s[i]=np.nan_to_num(time_DF[nom1]/(4*np.pi*T)*exp1(u[i])
                               +time_DF[nom1]**2*PdCQ, nan=0)
        else:    
            s[i]=np.nan_to_num(time_DF[nom1]/(4*np.pi*T)*exp1(u[i])
                               -time_DF[nom1]**2*PdCQ, nan=0)
        
    s_final=np.sum(s, axis=0)

    time1 = np.array(time_DF.index, dtype="float")/1e9 # temps (s)
    head1 = -s_final # rabattement (m) / '-' devant car valeurs positives de s

    if time1[0] == 0 and head1[0] == 0 :
        time1=time1[1:]
        head1=head1[1:]

    time1=time1/86400.
    
    return time1, head1


def regLog(pumpingData, time, head):
    
    duration=pumpingData['Model time S']
    rate=pumpingData['Pumping rate M3S']
    lenCycle=pumpingData['Daily pump time S']
    durationModel_Y=pumpingData['End time for log. reg. Y']

    tInterest_days=365.*durationModel_Y
    duration_D=duration/86400
    lenCycle_H=lenCycle/3600

    t1=365.*1.
    t2=365.*6.


    for q,p in zip(time, head):
        if abs(q - (9+(lenCycle_H)/24)) < 0.000001 :
            X1,Y1=q,p
        if abs(q - (duration_D+(lenCycle_H)/24)) < 0.000001 :
            X2,Y2=q,p
            
    A=(Y2-Y1)/(np.log10(X2)-np.log10(X1))

    Y3=Y1+A*(np.log10(t1)-np.log10(X1))
    Y4=Y1+A*(np.log10(t2)-np.log10(X1))
    Y5=Y1+A*(np.log10(tInterest_days)-np.log10(X1))
    Y0=Y1+A*(np.log10(0.1)-np.log10(X1))

    X=[0.1,X1,X2,t1,t2,tInterest_days]
    Y=[Y0,Y1,Y2,Y3,Y4,Y5]
    
    return X, Y



def plottingModelReg(parameters, pumpingData, time, head, X, Y):
    
    T=parameters['Transmissivity']
    T_str=np.format_float_scientific(T, exp_digits=1, precision=0)
    QHL=parameters['QuadHeadLoss']
    
    rate=pumpingData['Pumping rate M3S']
    lenCycle=pumpingData['Daily pump time S']    


    plt.semilogx(time, head, 'b-', label='T = {} m2/s\nPdc quad. = {} s2/m5\nQ = {} m3/h\nTemps journalier {} h'.format(T_str, QHL, rate*3600, lenCycle/3600))
    
    plt.semilogx([X[-1],X[-1]], [0, min(head)*1.20], 'r-')
    plt.semilogx(X,Y, 'r*-', label='s à {} ans = {:.2f} m\ns à {} ans = {:.2f} m\ns à {} ans = {:.2f} m'.format(int(X[-3]/365), Y[-3], int(X[-2]/365), Y[-2], int(X[-1]/365), Y[-1]))
    
    plt.xlabel('Temps (j)')
    plt.ylabel('Rabattement (m)')
    
    plt.xlim(xmax=X[-1]*1.2)
    plt.ylim(ymin=1.25*min(head))
    
    plt.legend()
    plt.grid('True')
    
    plt.show()


# MAIN ###########



# PARAM HYDRODYNAMIQUES ##

K = 5e-5                     # m/s
b = 1.                       # m
T = K * b                    # m2/s
Ss = 0.2                     # 1/m
S = Ss * b                   # -
r= 0.140/2                   # m
QHL = 100000.                # s2/m5

params = { 'Transmissivity': T, 'Storage': S, 'radius': r, 
          'QuadHeadLoss': QHL }




# PARAM POMPAGE ##

lenCycle_Hours=8.

# Etudier la sensibilité de ce paramètre
# mais 3 mois OK d'après premières analyses
duration_Months=4.

rate_M3H=4.

duration_Seconds=duration_Months*86400.*30.
lenCycle_Sec=lenCycle_Hours*3600.
rate_M3S=rate_M3H/3600.

durationModel_Years=12. # > 6


paramsPumping = {'Daily pump time S' : lenCycle_Sec,
                 'Pumping rate M3S' : rate_M3S,
                 'Model time S' : duration_Seconds,
                 'End time for log. reg. Y' : durationModel_Years }
                 



# CALCUL ##

# Définition de la séquence de pompage

dQ=makePumpSerieSeconds(paramsPumping)

# Transformation de la séquence de pompage en Data Frame pandas

t_DF=pumpingCycleDF(dQ)

# Calcul de Theis avec les cycles de pompage repos définis avant

to1,ho1=TheisQVar(params, dQ, t_DF)


# REGRESSION LOG ##

X_reg,Y_reg=regLog(paramsPumping,to1,ho1)


# PLOT ##

plottingModelReg(params, paramsPumping, to1, ho1, X_reg, Y_reg)














